const PDFDocument = require('pdfkit');
const { createObjectCsvWriter } = require('csv-writer');
const StudentProfile = require('../models/StudentProfile');
const aiService = require('../services/AI.service');
const fs = require('fs');
const path = require('path');

exports.generateStudentReport = async (req, res) => {
    try {
        const profile = await StudentProfile.findOne({ userId: req.user._id });
        if (!profile) return res.status(404).send({ error: 'Profile not found' });

        const readinessScore = aiService.calculateReadinessScore(profile);
        const doc = new PDFDocument();

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=placement_report_${profile.firstName}.pdf`);

        doc.pipe(res);

        // PDF Design
        doc.fillColor('#800000').fontSize(24).text('Amrita Placement Readiness Report', { align: 'center' });
        doc.moveDown();
        doc.strokeColor('#FFD700').lineWidth(2).moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown();

        doc.fillColor('black').fontSize(14).text(`Name: ${profile.firstName} ${profile.lastName}`);
        doc.text(`Department: ${profile.department}`);
        doc.text(`CGPA: ${profile.cgpa}`);
        doc.text(`Batch: ${profile.batch}`);
        doc.moveDown();

        doc.fillColor('#800000').fontSize(18).text(`Readiness Score: ${Math.round(readinessScore)}%`, { underline: true });
        doc.moveDown();

        doc.fillColor('black').fontSize(12).text('Skills:', { bold: true });
        profile.skills.forEach(skill => {
            doc.text(`- ${skill.name} (${skill.level})`);
        });

        doc.moveDown();
        doc.fontSize(10).fillColor('gray').text('Generated by AI placement tracking system. Institutional confidential.', { align: 'bottom' });

        doc.end();
    } catch (e) {
        res.status(500).send(e);
    }
};

exports.generateAdminCSV = async (req, res) => {
    try {
        const students = await StudentProfile.find();
        const csvPath = path.join(__dirname, '../temp_students.csv');

        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'rollNumber', title: 'Roll Number' },
                { id: 'firstName', title: 'First Name' },
                { id: 'lastName', title: 'Last Name' },
                { id: 'email', title: 'Email' },
                { id: 'phone', title: 'Phone' },
                { id: 'department', title: 'Department' },
                { id: 'cgpa', title: 'CGPA' },
                { id: 'batch', title: 'Batch' },
                { id: 'backlogs', title: 'Backlogs' },
                { id: 'placementStatus', title: 'Placement Status' },
                { id: 'offeredCompany', title: 'Company' },
                { id: 'offeredCTC', title: 'CTC' }
            ]
        });

        await csvWriter.writeRecords(students);

        res.download(csvPath, 'student_placement_data.csv', (err) => {
            if (err) res.status(500).send(err);
            try {
                fs.unlinkSync(csvPath); // Cleanup
            } catch (cleanupErr) {
                console.error('Error deleting temp csv:', cleanupErr);
            }
        });
    } catch (e) {
        console.error('CSV Generation Error:', e);
        res.status(500).send(e);
    }
};

exports.generateCompanyCSV = async (req, res) => {
    try {
        const students = await StudentProfile.find({ placementStatus: 'placed' });
        const companyStats = {};

        // Aggregate data
        students.forEach(student => {
            const company = student.offeredCompany || 'Unknown';
            if (!companyStats[company]) {
                companyStats[company] = {
                    name: company,
                    count: 0,
                    totalCTC: 0,
                    minCTC: Infinity,
                    maxCTC: -Infinity,
                    departments: {}
                };
            }
            companyStats[company].count++;
            companyStats[company].totalCTC += (student.offeredCTC || 0);
            companyStats[company].minCTC = Math.min(companyStats[company].minCTC, student.offeredCTC || Infinity);
            companyStats[company].maxCTC = Math.max(companyStats[company].maxCTC, student.offeredCTC || -Infinity);

            const dept = student.department || 'Unknown';
            companyStats[company].departments[dept] = (companyStats[company].departments[dept] || 0) + 1;
        });

        // Format for CSV
        const records = Object.values(companyStats).map(c => ({
            name: c.name,
            count: c.count,
            avgCTC: (c.totalCTC / c.count).toFixed(2),
            minCTC: c.minCTC === Infinity ? 0 : c.minCTC,
            maxCTC: c.maxCTC === -Infinity ? 0 : c.maxCTC,
            deptBreakdown: Object.entries(c.departments).map(([d, n]) => `${d}:${n}`).join('; ')
        }));

        const csvPath = path.join(__dirname, '../temp_companies.csv');
        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'name', title: 'Company Name' },
                { id: 'count', title: 'Total Hires' },
                { id: 'avgCTC', title: 'Average CTC' },
                { id: 'minCTC', title: 'Min CTC' },
                { id: 'maxCTC', title: 'Max CTC' },
                { id: 'deptBreakdown', title: 'Department Breakdown' }
            ]
        });

        await csvWriter.writeRecords(records);

        res.download(csvPath, 'company_placement_stats.csv', (err) => {
            if (err) res.status(500).send(err);
            try {
                fs.unlinkSync(csvPath);
            } catch (cleanupErr) {
                console.error('Error deleting temp csv:', cleanupErr);
            }
        });

    } catch (e) {
        console.error('Company CSV Error:', e);
        res.status(500).send(e.message);
    }
};
